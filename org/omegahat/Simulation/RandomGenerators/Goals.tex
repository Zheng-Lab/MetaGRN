\documentclass{article}

\title{Goals for the Distributed Random Number Generation Package}
\author{Greg Warnes}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

This text outlines my intentions and implementation goals and for the
distributed random number generation library contained in
\verb+org.omegahat.Simulation.RandomGenerators+ .

\section{Overview}

I intend to make the java library
\verb+org.omegahat.Simulation.RandomGenerators+  a useful tool for
performing concurrent simulations accessible from arbitrary languages
using CORBA.  In particular, I wish to provide Administrator classes
and corresponding PRNG's for the Collings Compound random number
generator as well as the random generators available in the SPRNG
library.  The administrator and generators will be usable with
Omegahat, (standard) JAVA, S, S-plus, R, and custom C/C++ programs.

The current problem that this library is designed to solve is the
difficulty in providing independent random number streams for
simulations that are run concurrently.  A standard example is a set of
simulations implemented in S-plus that are run concurrently on
different machines.  While the current random number generators in S
and S-plus (R ?), do save the state of the random number generator on
exit, and restore it on entry -- assuring non-overlapping streams of
random numbers between sequential jobs, they do not easily permit
obtaining independent random sequences in concurrently running jobs.

In many cases, the user is unaware of the problem and simply runs the
concurrent jobs.  This has the possibility of producing the same
sequence of pseudo-random numbers for each job.  If the concurrent
jobs are all performing the same computations, the (near) identical
random streams streams may produce (near) identical computed results,
instead of independent replications.

More sophisticated users may be aware of the problem and can attempt
to provide independent random streams for each job by using a
different seed for each.  However, it can be quite difficult to
discover what seed to provide each job to ensure non-overlapping
sequences.  The common practice is to arbitrarily select different
seeds for each job.  This, of course, does not ensure independent
random sequences.  The user may have made unfortunate choices of the
seed values so that the sequence of random numbers for separate jobs
are overlapping or are otherwise related.

\section{An Example of the Problem}

One example where overlapping sequences can cause significant problems
is bootstrapping where the random sequence is used to select elements
included in the bootstrap sample.  If the elements are
selected in the most straightforward way --- by using a transformation of
the random number as an index into the list of observed elements ---
overlapping sequences can lead to nearly identical bootstrap samples.

For illustration, consider generating a bootstrap sample from a vector
of 10 elements.  Assume that the random number generator for two jobs
are initialized so that the second is identical to the first except for the
first element.   This would occur if the random number generator of
the second job was seeded with the first element produced by the first
job.  

Take the first 11 random values produced by the generator, normalized
to be an integer between  1 and 10 to be
[ 8 10  9  2  9  7  1  9  9  2  4 ].  

The first bootstrap sample of the first job will contain  the elements

  [ 8 10  9  2  9  7  1  9  9  2 ].

the first bootstrap sample of the second job will contain the elements

  [ 10  9  2  9  7  1  9  9  2  4 ].

Note that these two samples differ by only one element.  Further, note
that if this is the only use of random numbers in the jobs, *all*
bootstrap samples generated by these two jobs will have this
property.  Also note that increasing the size of the bootstrap sample
makes this problem \emph{worse}, because a greater proportion of
each bootstrap sample will be identical.

While this particular example is rather extreme, it is possible for
similar situations to arise in practice without the user becoming
aware of the problem.

\section{Goals}

\begin{enumerate}
  \item Complete IDL for all interfaces defined in
	\verb+org.omegahat.Simulations.RandomGenerators+
  \item Modify \verb+PRNGAdminServer+ to return \verb+PRNGState+'s 
  \item Create CORBA server for \verb+PRNGFactory+
  \item Create C/C++ Factory and PRNG for \verb+CollingsPRNG+
  \item Implement CORBA interface for existing SPRNG PRNG's
\end{enumerate}

\end{document}










